/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
import _ from "lodash";
import {
  createEmptyMonthDataModel,
  isMonthModelEmpty,
  MonthDataModel,
} from "../../state/schedule-data/schedule-data.model";
import { VerboseDateHelper } from "../../helpers/verbose-date.helper";
import { RevisionKey, RevisionType, ScheduleKey } from "./persistance-store.model";
import { MonthPersistProvider } from "./month-persistance-provider";

export async function saveMonthRevision(
  revisionType: RevisionType,
  monthDataModel: MonthDataModel,
  monthPersistProvider: MonthPersistProvider
): Promise<void> {
  if (isMonthModelEmpty(monthDataModel)) {
    return;
  }

  const oppositeRevisionType = revisionType === "actual" ? "primary" : "actual";

  const oppositeRevision = await getMonthRevision(
    monthDataModel.scheduleKey.getRevisionKey(oppositeRevisionType),
    monthPersistProvider
  );

  const isMonthInFuture = VerboseDateHelper.isMonthInFuture(
    monthDataModel.scheduleKey.month,
    monthDataModel.scheduleKey.year
  );

  const shouldSaveOppositeRevision =
    _.isNil(oppositeRevision) ||
    oppositeRevision.isAutoGenerated ||
    revisionType === "primary" || // update actual when saving primary
    isMonthInFuture; // primary and actual should be sync in the future

  if (shouldSaveOppositeRevision) {
    await monthPersistProvider.saveMonth(oppositeRevisionType, monthDataModel);
  }

  await monthPersistProvider.saveMonth(revisionType, monthDataModel);
}

export function getMonthRevision(
  revisionKey: RevisionKey,
  monthPersistProvider: MonthPersistProvider
): Promise<MonthDataModel | undefined> {
  return monthPersistProvider.getMonth(revisionKey);
}

export async function getOrGenerateMonthRevision(
  monthKey: ScheduleKey,
  revision: RevisionType,
  baseMonth: MonthDataModel,
  monthPersistProvider: MonthPersistProvider
): Promise<MonthDataModel> {
  let monthDataModel = await getMonthRevision(
    monthKey.getRevisionKey(revision),
    monthPersistProvider
  );

  if (_.isNil(monthDataModel)) {
    monthDataModel = await generateMonthRevision(
      monthKey,
      revision,
      baseMonth,
      monthPersistProvider
    );
  }

  return monthDataModel;
}

export async function getOrGenerateMonthNeighbours(
  month: MonthDataModel,
  monthPersistProvider: MonthPersistProvider
): Promise<[MonthDataModel, MonthDataModel]> {
  const scheduleKey = new ScheduleKey(month.scheduleKey.month, month.scheduleKey.year);

  const { nextMonthKey } = scheduleKey;
  const isNextMonthInFuture = VerboseDateHelper.isMonthInFuture(
    nextMonthKey.month,
    nextMonthKey.year
  );
  const nextMonthRevision = isNextMonthInFuture ? "primary" : "actual";

  return [
    await getOrGenerateMonthRevision(
      scheduleKey.prevMonthKey,
      "actual",
      month,
      monthPersistProvider
    ),
    await getOrGenerateMonthRevision(nextMonthKey, nextMonthRevision, month, monthPersistProvider),
  ];
}

async function generateMonthRevision(
  monthKey: ScheduleKey,
  revision: RevisionType,
  baseMonth: MonthDataModel,
  monthPersistProvider: MonthPersistProvider
): Promise<MonthDataModel> {
  const monthDataModel = createEmptyMonthDataModel(monthKey, baseMonth);
  await saveMonthRevision(revision, monthDataModel, monthPersistProvider);
  return monthDataModel;
}
