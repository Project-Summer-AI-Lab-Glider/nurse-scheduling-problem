/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

import { ScheduleError } from "../../state/schedule-data/schedule-errors/schedule-error.model";
import {
  ContractType,
  WorkerDescription,
  WorkerType,
} from "../../state/schedule-data/worker-info/worker-info.model";
import { FoundationInfoOptions } from "../schedule-providers/foundation-info-provider.model";
import {
  Schedule,
  ScheduleProvider,
  Sections,
} from "../schedule-providers/schedule-provider.model";
import { ChildrenInfoParser } from "./children-info.parser";
import { ExtraWorkersInfoParser } from "./extra-workers-info.parser";
import { FoundationInfoHeaders, FoundationInfoParser } from "./foundation-info.parser";
import { MetaDataParser } from "./metadata.parser";
import { ShiftsInfoParser } from "./shifts-info.parser";
import {
  DEFAULT_CONTRACT_TYPE,
  DEFAULT_WORKER_TYPE,
  WorkersInfoParser,
} from "./workers-info.parser";
import { ShiftsTypesInfoParser } from "./shifts-types-info.parser";

export type WorkerTypeDict = { [key: string]: WorkerType };
export type ContractTypeDict = { [key: string]: ContractType };
export class ScheduleParser implements ScheduleProvider {
  readonly sections: Sections;

  readonly workersInfo: WorkersInfoParser;

  readonly shiftsInfo: ShiftsTypesInfoParser;

  readonly schedule: Schedule;

  readonly isAutoGenerated: boolean;

  parseErrors: ScheduleError[] = [];

  constructor(
    readonly month: number,
    readonly year: number,
    rawSchedule: string[][][],
    workersInfo: string[][],
    shiftsInfo: string[][]
  ) {
    this.sections = this.parseSections(rawSchedule);
    this.workersInfo = new WorkersInfoParser(workersInfo);
    this.shiftsInfo = new ShiftsTypesInfoParser(shiftsInfo);
    this.isAutoGenerated = false;
    this.schedule = new Schedule(this);
  }

  private parseSections(rawSchedule: string[][][]): Sections {
    const foundationInfoHeaders = Object.values(FoundationInfoHeaders);

    const foundationInfoRaw = rawSchedule.find((r) =>
      foundationInfoHeaders.some((h) => r[0][0].toLowerCase().trim() === h)
    );
    const metadataRaw = foundationInfoRaw?.find(
      (r) => r[0].toLowerCase().trim() === FoundationInfoHeaders.MonthDates
    );
    const metadata = new MetaDataParser(this.month, this.year, metadataRaw);

    const childrenRaw = foundationInfoRaw?.find(
      (r) => r[0].toLowerCase().trim() === FoundationInfoHeaders.ChildrenInfo
    );
    const children = new ChildrenInfoParser(metadata, childrenRaw);

    const extraWorkersRaw = foundationInfoRaw?.find(
      (r) => r[0].toLowerCase().trim() === FoundationInfoHeaders.ExtraWorkers
    );
    const extraWorkers = new ExtraWorkersInfoParser(metadata, extraWorkersRaw);

    rawSchedule.splice(rawSchedule.indexOf(foundationInfoRaw!), 1);

    const teams = rawSchedule.map(
      (section, index) => new ShiftsInfoParser(metadata, index + 1, section)
    );

    const parsers: FoundationInfoOptions = {
      ChildrenInfo: children,
      Teams: teams,
      ExtraWorkersInfo: extraWorkers,
    };

    const foundationParser = new FoundationInfoParser(parsers);
    return {
      Teams: teams,
      FoundationInfo: foundationParser,
      Metadata: metadata,
    };
  }

  getWorkerTypes(): WorkerTypeDict {
    if (!this.workersInfo.isExists) {
      return this.mockWorkerInfo<"type">(DEFAULT_WORKER_TYPE);
    }
    return this.getFromWorkerDescription("type");
  }

  getWorkerContractTypes(): ContractTypeDict {
    if (!this.workersInfo.isExists) {
      return this.mockWorkerInfo<"contractType">(DEFAULT_CONTRACT_TYPE);
    }
    return this.getFromWorkerDescription("contractType");
  }

  private mockWorkerInfo<K extends keyof WorkerDescription>(
    defaultValue: WorkerDescription[K]
  ): { [key: string]: WorkerDescription[K] } {
    const result: { [key: string]: WorkerDescription[K] } = {};
    const teamsProviders = this.sections.Teams;
    teamsProviders.forEach((provider) => {
      Object.keys(provider.workerShifts).forEach((workerName) => {
        result[workerName] = defaultValue;
      });
    });
    return result;
  }

  private getFromWorkerDescription<K extends keyof WorkerDescription>(
    key: K
  ): { [key: string]: WorkerDescription[K] } {
    const workers = this.workersInfo.workerDescriptions;
    const result: { [key: string]: WorkerDescription[K] } = {};
    workers.forEach((worker) => {
      result[worker.name] = worker[key];
    });
    return result;
  }
}
